<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0079)http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment2/ --><HTML><HEAD><TITLE>6.837 Assignment 2</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="Microsoft FrontPage 5.0" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#ffffff background=Assignment3_files/blbkgnd.gif>
<H1>Intro to Computer Graphics<BR>Assignment 3: Transformations &amp; 
Additional Primitives</H1>
<P>In this assignment, you will add new primitives (planes and triangles) and 
affine transformations. You will also implement a perspective camera, and two 
simple shading modes: normal visualization and diffuse shading. For the normal 
visualization, you will simply display the absolute value of the coordinates of 
the normal vector as an <EM>(r, g, b)</EM> color. For example, a normal pointing 
in the positive or negative <EM>z</EM> direction will be displayed as pure blue 
<EM>(0, 0, 1)</EM>. You should use black as the color for the background 
(undefined normal). 
<P>Diffuse shading is our first step toward modeling the interaction of light 
and materials. Given the direction to the light <B>L</B> and the normal <B>N</B> 
we can compute the diffuse shading as a clamped dot product: 
<P>
<TABLE border=0>
  <TBODY>
  <TR>
    <TD width=20>&nbsp;</TD>
    <TD><EM>d</EM></TD>
    <TD>= <B>L <SUP>.</SUP> N</B> &nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD>if <B>L <SUP>.</SUP> N</B> &gt; 0</TD></TR>
  <TR>
    <TD>&nbsp; </TD>
    <TD>&nbsp; 
    <TD>= 0 
    <TD>otherwise </TD></TR></TBODY></TABLE>
<P>If the visible object has color <EM>c<SUB>object</SUB> = (r, g, b)</EM>, and 
the light source has color <EM>c<SUB>light</SUB> = (L<SUB>r</SUB>, 
L<SUB>g</SUB>, L<SUB>b</SUB>)</EM>, then the pixel color is 
<EM>c<SUB>pixel</SUB> = (rL<SUB>r</SUB>d, gL<SUB>g</SUB>d, 
bL<SUB>b</SUB>d)</EM>. Multiple light sources are handled by simply summing 
their contributions. We can also include an <EM>ambient</EM> light with color 
c<SUB>ambient</SUB>, which can be very helpful in debugging. Without it, parts 
facing away from the light source appear completely black. Putting this all 
together, the formula is: 
<P>&nbsp;&nbsp;&nbsp;&nbsp; c<SUB>pixel</SUB> &nbsp;=&nbsp; c<SUB>ambient</SUB> 
* c<SUB>object</SUB> + SUM<SUB>i</SUB> [ clamped(<B>L<SUB>i</SUB> <SUP>.</SUP> 
N</B>) * c<SUB>light<SUB>i</SUB></SUB> * c<SUB>object</SUB> ] 
<P>Color vectors are multiplied term by term. Note that if the ambient light 
color is <EM>(1, 1, 1)</EM> and the light source color is <EM>(0, 0, 0)</EM>, 
then you have the constant shading used in assignment 1. 
<H3>Tasks</H3>
<UL>
  <P>
  <LI>The <TT>Hit</TT> class has been modified to store the normal of the 
  intersection point. Update your sphere intersection routine to pass the normal 
  to the <TT>Hit</TT>. 
  <P>
  <UL>
    <LI><a href="Assignment3_files/hit.h">hit.h</a> 
    </LI></UL>
  <P></P>
  <LI>Implement the new rendering mode, normal visualization. Add code to parse 
  an additional command line option <TT>-normals &lt;normal_file.tga&gt;</TT> to 
  specify the output file for this visualization (see examples below). 
  <P></P>
  <LI>Add diffuse shading. We provide the pure virtual <TT>Light</TT> class and 
  a simple directional light source. Scene lighting can be accessed with the 
  <TT>SceneParser::getLight()</TT> and <TT>SceneParser::getAmbientLight()</TT> 
  methods. Use the <TT>Light</TT> class method: <PRE>   void getIllumination (const Vec3f &amp;p, Vec3f &amp;dir, Vec3f &amp;col); 
</PRE>
  <P>to find the illumination at a particular location in space. p is the 
  intersection point that you want to shade, and the function returns the 
  normalized direction toward the light source in <TT>dir</TT> and the light 
  color and intensity in <TT>col</TT>. 
  <P>
  <UL>
    <LI><a href="Assignment3_files/light.h">light.h</a> 
    </LI></UL>
  <P></P>
  <LI>In test scenes 5 &amp; 7 below, we've asked you to render the "wrong" or 
  "back" side of both a Sphere and a Triangle primitive. Add the 
  <TT>-shade_back</TT> option to your raytracer. When this option is specified, 
  we'd like you to treat both sides of your object surfaces in the same manner. 
  This means you'll need to flip the normal when the eye is on the "wrong" side 
  of the surface (when the dot product of the ray direction &amp; the normal is 
  positive). Do this normal flip just before you shade a pixel, not within the 
  object intersection code. If the <TT>-shade_back</TT> flag is not specified, 
  you should shade back-facing surfaces differently, to aid in debugging. 
  Back-facing surfaces must be detected to implement refraction through 
  translucent objects, and are often not rendered at all for efficiency in 
  real-time applications. We'll see this again in upcoming lectures and 
  assignments. 
  <P></P>
  <LI>Add a <TT>PerspectiveCamera</TT> class that derives from <TT>Camera</TT>. 
  Choose your favorite internal camera representation. Similar to an 
  orthographic camera, the scene parser provides you with the center, direction, 
  and up vectors. But for a perspective camera, the field of view is specified 
  with an angle (as shown in the diagram). <PRE>   PerspectiveCamera(Vec3f ¢er, Vec3f &amp;direction, Vec3f &amp;up, float angle);
</PRE>
  <P>
  <IMG src="Assignment3_files/perspective_camera.png" width="500" height="436"> 
  <P>Hint: In class, we often talk about a "virtual screen" in space. You can 
  calculate the location and extents of this "virtual screen" using some simple 
  trigonometry. You can then interpolate over points on the virtual screen in 
  the same way you interpolated over points on the screen for the orthographic 
  camera. Direction vectors can then be calculated by subtracting the camera 
  center point from the screen point. Don't forget to normalize! In contrast, if 
  you interpolate over the camera angle to obtain your direction vectors, your 
  scene will look distorted - especially for large camera angles, which will 
  give the appearance of a fisheye lens. 
  <P>Note: the distance to the image plane and the size of the image plane are 
  unnecessary. Why? 
  <P></P>
  <LI>Implement <TT>Plane</TT>, an infinite plane primitive derived from 
  <TT>Object3D</TT>. Use the representation of your choice, but the constructor 
  is assumed to be: <PRE> 
   Plane(Vec3f &amp;normal, float d, Material *m); 
</PRE>
  <P><TT>d</TT> is the offset from the origin, meaning that the plane equation 
  is <B>P <SUP>.</SUP> n</B> = d. You can also implement other constructors 
  (e.g. using 3 points). Implement <TT>intersect</TT>, and remember that you 
  also need to update the normal stored by <TT>Hit</TT>, in addition to the 
  intersection distance <EM>t</EM> and color. 
  <P></P>
  <LI>Implement a triangle primitive which also derives from <TT>Object3D</TT>. 
  The constructor takes 3 vertices: <PRE>   Triangle(Vec3f &amp;a, Vec3f &amp;b, Vec3f &amp;c, Material *m);
</PRE>
  <P>Use the method of your choice to implement the ray-triangle intersection: 
  general polygon with in-polygon test, barycentric coordinates, etc. We can 
  compute the normal by taking the cross-product of two edges, but note that the 
  normal direction for a triangle is ambiguous. We'll use the usual convention 
  that counter-clockwise vertex ordering indicates the outward-facing side. If 
  your renderings look incorrect, just flip the cross-product to match the 
  convention. 
  <P></P>
  <LI>Derive a subclass <TT>Transform</TT> from <TT>Object3D</TT>. Similar to a 
  <TT>Group</TT>, a <TT>Transform</TT> will store a pointer to an 
  <TT>Object3D</TT> (but only one, not an array). The constructor of a 
  <TT>Transform</TT> takes a 4x4 matrix as input and a pointer to the 
  <TT>Object3D</TT> modified by the transformation: <PRE>   Transform(Matrix &amp;m, Object3D *o);
</PRE>The <TT>intersect</TT> routine will first transform the ray, then 
  delegate to the <TT>intersect</TT> routine of the contained object. Make sure 
  to correctly transform the resulting normal according to the rule seen in 
  lecture. You may choose to normalize the direction of the transformed ray or 
  leave it un-normalized. If you decide not to normalize the direction, you 
  might need to update some of your intersection code. 
  <P></P>
  <LI>Extra credit: Implement two different ray-triangle intersection methods 
  and compare; add cones or cylinders; implement Constructive Solid Geometry 
  (CSG), IFS, or non-linear cameras. For CSG, you need to implement a new 
  <TT>intersectAll</TT> method for your <TT>Object3D</TT> classes. This function 
  returns <EM>all</EM> of the intersections of the ray with the object, not just 
  the closest one. For additional primitives such as cones and cylinders, 
  implement the simple case of axis-aligned primitives and use transformations. 
  </LI></UL>
<H3>Updated Files</H3>
<UL>
  <LI><a href="Assignment3_files/scene_parser.h">scene_parser.h</a> 

  <LI><a href="Assignment3_files/scene_parser.C">scene_parser.C</a> 
  </LI></UL>If you're interested, here's the <A 
href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment2/grammar.html">scene 
description file grammar</A> used in this assignment. 
<P>You will need to edit the Makefile to include any .C files that you add to 
the project. 
<H3>Hints</H3>
<UL>
  <LI>Parse the arguments of the program in a separate function. It will make 
  your code easier to read. 
  <LI>Implement the normal visualization and diffuse shading before the 
  transformations. 
  <LI>Use the various rendering modes (normal, diffuse, distance) to debug your 
  code. </LI></UL>
<H3>Input Files</H3>
<UL>
  <LI><a href="Assignment3_files/scene2_01.txt">scene2_01.txt</a> 

  <LI><a href="Assignment3_files/scene2_02.txt">scene2_02.txt</a> 

  <LI><a href="Assignment3_files/scene2_03.txt">scene2_03.txt</a> 

  <LI><a href="Assignment3_files/scene2_04.txt">scene2_04.txt</a> 

  <LI><a href="Assignment3_files/scene2_05.txt">scene2_05.txt</a> 

  <LI><a href="Assignment3_files/scene2_06.txt">scene2_06.txt</a> 

  <LI><a href="Assignment3_files/scene2_07.txt">scene2_07.txt</a> 

  <LI><a href="Assignment3_files/scene2_08.txt">scene2_08.txt</a> 

  <LI><a href="Assignment3_files/scene2_09.txt">scene2_09.txt</a> 

  <LI><a href="Assignment3_files/scene2_10.txt">scene2_10.txt</a> 

  <LI><a href="Assignment3_files/scene2_11.txt">scene2_11.txt</a> 

  <LI><a href="Assignment3_files/scene2_12.txt">scene2_12.txt</a> 

  <LI><a href="Assignment3_files/scene2_13.txt">scene2_13.txt</a> 

  <LI><a href="Assignment3_files/scene2_14.txt">scene2_14.txt</a> 

  <LI><a href="Assignment3_files/scene2_15.txt">scene2_15.txt</a> 

  <LI><a href="Assignment3_files/scene2_16.txt">scene2_16.txt</a> 
  (new! to test t scale) </LI></UL>
<H3>Triangle Meshes (.obj format)</H3>
<P>
<UL>
  <LI><a href="Assignment3_files/cube.obj">cube.obj</a> 

  <LI><a href="Assignment3_files/bunny_200.obj">bunny_200.obj</a> 

  <LI><a href="Assignment3_files/bunny_1k.obj">bunny_1k.obj</a> 
  </LI></UL>
<H3>Sample Results</H3>
<P><PRE>raytracer -input scene2_01.txt -size 200 200 -output output2_01.tga
raytracer -input scene2_02.txt -size 200 200 -output output2_02.tga
</PRE><IMG src="Assignment3_files/output2_01.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/output2_02.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_03.txt -size 200 200 -output output2_03.tga -normals normals2_03.tga
</PRE>
<P><IMG src="Assignment3_files/output2_03.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_03.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_04.txt -size 200 200 -output output2_04.tga -normals normals2_04.tga
</PRE><IMG src="Assignment3_files/output2_04.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_04.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_05.txt -size 200 200 -output output2_05.tga -depth 9 11 depth2_05.tga -normals normals2_05.tga -shade_back
raytracer -input scene2_05.txt -size 200 200 -output output2_05_no_back.tga
</PRE><IMG src="Assignment3_files/output2_05.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/depth2_05.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_05.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/output2_05_no_back.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_06.txt -size 200 200 -output output2_06.tga -depth 8 20 depth2_06.tga -normals normals2_06.tga
</PRE><IMG src="Assignment3_files/output2_06.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/depth2_06.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_06.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_07.txt -size 200 200 -output output2_07.tga -depth 9 11 depth2_07.tga -normals normals2_07.tga -shade_back
raytracer -input scene2_07.txt -size 200 200 -output output2_07_no_back.tga
</PRE><IMG src="Assignment3_files/output2_07.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/depth2_07.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_07.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/output2_07_no_back.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_08.txt -size 200 200 -output output2_08.tga
raytracer -input scene2_09.txt -size 200 200 -output output2_09.tga
raytracer -input scene2_10.txt -size 200 200 -output output2_10.tga
</PRE><IMG src="Assignment3_files/output2_08.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/output2_09.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/output2_10.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_11.txt -size 200 200 -output output2_11.tga -normals normals2_11.tga
</PRE><IMG src="Assignment3_files/output2_11.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_11.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_12.txt -size 200 200 -output output2_12.tga -normals normals2_12.tga
</PRE><IMG src="Assignment3_files/output2_12.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_12.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_13.txt -size 200 200 -output output2_13.tga -normals normals2_13.tga
</PRE><IMG src="Assignment3_files/output2_13.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/normals2_13.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_14.txt -size 200 200 -output output2_14.tga
raytracer -input scene2_15.txt -size 200 200 -output output2_15.tga
</PRE><IMG src="Assignment3_files/output2_14.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/output2_15.png" width="200" height="200"> 
<P><PRE>raytracer -input scene2_16.txt -size 200 200 -output output2_16.tga -depth 2 7 depth2_16.tga
</PRE><IMG src="Assignment3_files/output2_16.png" width="200" height="200"> 
<IMG 
src="Assignment3_files/depth2_16.png" width="200" height="200"> 
<P>See the main <A 
href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/index.html">Assignments 
Page</A> for submission information. 
<HR>
</BODY></HTML>